{"version":3,"sources":["webpack:///browser-acl.js","webpack:///webpack/bootstrap d980bbec356b5650364b","webpack:///./index.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","value","GlobalRule","Acl","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","assumeGlobal","sub","_ref","arguments","undefined","_ref$strict","strict","this","rules","Map","policies","registry","WeakMap","verbs","subject","_this","test","subjectName","subjectMapper","Array","isArray","forEach","verb","set","policy","policy_","klass","user","Error","_len","args","_key","beforeAll","result","apply","concat","Boolean","subjects","_len2","_key2","_this2","some","can","_len3","_key3","_this3","every","User","acl","slice","isFun","has","constructor","delete","removeRules","removePolicy"],"mappings":"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","file":"browser-acl.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!************************!*\\\n  !*** multi ./index.js ***!\n  \\************************/\n/*! dynamic exports provided */\n/*! all exports used */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! /Users/mblarsen/workspace/mblarsen/browser-acl/index.js */1);\n\n\n/***/ }),\n/* 1 */\n/*!******************!*\\\n  !*** ./index.js ***!\n  \\******************/\n/*! exports provided: GlobalRule, default */\n/*! all exports used */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GlobalRule\", function() { return GlobalRule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Acl; });\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar GlobalRule = 'GLOBAL_RULE';\n\nvar assumeGlobal = function assumeGlobal(sub) {\n  return typeof sub === 'boolean' || typeof sub === 'undefined' || typeof sub === 'function' && sub.name === '';\n};\n\n/**\n * Simple ACL library for the browser inspired by Laravel's guards and policies.\n */\n\nvar Acl = function () {\n\n  /**\n   * browser-acl\n   *\n   * @access public\n   * @param {Object} options\n   * @param {Boolean} {strict=false}={} Errors out on unknown verbs when true\n   * @returns {Acl}\n   */\n  function Acl() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$strict = _ref.strict,\n        strict = _ref$strict === undefined ? false : _ref$strict;\n\n    _classCallCheck(this, Acl);\n\n    this.strict = strict;\n    this.rules = new Map();\n    this.policies = new Map();\n    this.registry = new WeakMap();\n  }\n\n  /**\n   * You add rules by providing a verb, a subject and an optional\n   * test (that otherwise defaults to true).\n   *\n   * If the test is a function it will be evaluated with the params:\n   * user, subject, and subjectName. The test value is ultimately evaluated\n   * for truthiness.\n   *\n   * Examples:\n   *\n   * ```javascript\n   * acl.rule('create', Post)\n   * acl.rule('edit', Post, (user, post) => post.userId === user.id)\n   * acl.rule('edit', Post, (user, post, verb, additionalParameter, secondAdditionalParameter) => true)\n   * acl.rule('delete', Post, false) // deleting disabled\n   * acl.rule('purgeInactive', user => user.isAdmin) // global rule\n   * ```\n   *\n   * @access public\n   * @param {Array<string>|string} verbs\n   * @param {Function|Object|string} subject?\n   * @param {Boolean|Function} test=true\n   * @returns {Acl}\n   */\n\n\n  _createClass(Acl, [{\n    key: 'rule',\n    value: function rule(verbs, subject) {\n      var _this = this;\n\n      var test = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (assumeGlobal(subject)) {\n        test = typeof subject === 'undefined' ? true : subject;\n        subject = GlobalRule;\n      }\n      var subjectName = this.subjectMapper(subject);\n      var verbs_ = Array.isArray(verbs) ? verbs : [verbs];\n      verbs_.forEach(function (verb) {\n        var rules = _this.rules.get(subjectName) || {};\n        rules[verb] = test;\n        _this.rules.set(subjectName, rules);\n      });\n      return this;\n    }\n\n    /**\n     * You can group related rules into policies for a subject. The policies\n     * properties are verbs and they can plain values or functions.\n     *\n     * If the policy is a function it will be new'ed up before use.\n     *\n     * ```javascript\n     *   class Post {\n     *     constructor() {\n     *       this.view = true       // no need for a functon\n     *       this.delete = false    // not really necessary since an abscent\n     *                              // verb has the same result\n     *     }\n     *     beforeAll(verb, user, ...theRest) {\n     *       if (user.isAdmin) {\n     *         return true\n     *       }\n     *       // return nothing (undefined) to pass it on to the other rules\n     *     }\n     *     edit(user, post, verb, additionalParameter, secondAdditionalParameter) {\n     *       return post.id === user.id\n     *     }\n     *   }\n     * ```\n     *\n     * Policies are useful for grouping rules and adding more complex logic.\n     *\n     * @access public\n     * @param {Object} policy A policy with properties that are verbs\n     * @param {Function|Object|string} subject\n     * @returns {Acl}\n     */\n\n  }, {\n    key: 'policy',\n    value: function policy(_policy, subject) {\n      var policy_ = typeof _policy === 'function' ? new _policy() : _policy;\n      var subjectName = this.subjectMapper(subject);\n      this.policies.set(subjectName, policy_);\n      return this;\n    }\n\n    /**\n     * Explicitly map a class or constructor function to a name.\n     *\n     * You would want to do this in case your code is heavily\n     * minified in which case the default mapper cannot use the\n     * simple \"reflection\" to resolve the subject name.\n     *\n     * Note: If you override the subjectMapper this is not used,\n     * bud it can be used manually through `this.registry`.\n     *\n     * @access public\n     * @param {Function} klass A class or constructor function\n     * @param {string} subjectName\n     */\n\n  }, {\n    key: 'register',\n    value: function register(klass, subjectName) {\n      this.registry.set(klass, subjectName);\n      return this;\n    }\n\n    /**\n     * Performs a test if a user can perform action on subject.\n     *\n     * The action is a verb and the subject can be anything the\n     * subjectMapper can map to a subject name.\n     *\n     * E.g. if you can to test if a user can delete a post you would\n     * pass the actual post. Where as if you are testing us a user\n     * can create a post you would pass the class function or a\n     * string.\n     *\n     * ```javascript\n     *   acl->can(user, 'create', Post)\n     *   acl->can(user, 'edit', post)\n     *   acl->can(user, 'edit', post, additionalParameter, secondAdditionalParameter)\n     * ```\n     *\n     * Note that these are also available on the user if you've used\n     * the mixin:\n     *\n     * ```javascript\n     *   user->can('create', Post)\n     *   user->can('edit', post)\n     * ```\n     *\n     * @access public\n     * @param {Object} user\n     * @param {string} verb\n     * @param {Function|Object|string} subject\n     * @param {...*} args Any other param is passed into rule\n     * @return Boolean\n     */\n\n  }, {\n    key: 'can',\n    value: function can(user, verb, subject) {\n      subject = typeof subject === 'undefined' ? GlobalRule : subject;\n      var subjectName = this.subjectMapper(subject);\n\n      var policy = this.policies.get(subjectName);\n      var rules = policy || this.rules.get(subjectName);\n\n      if (typeof rules === 'undefined') {\n        if (this.strict) {\n          throw new Error('Unknown subject \"' + subjectName + '\"');\n        }\n        return false;\n      }\n\n      for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n\n      if (policy && typeof policy.beforeAll === 'function') {\n        var result = policy.beforeAll.apply(policy, [verb, user, subject, subjectName].concat(args));\n        if (typeof result !== 'undefined') {\n          return result;\n        }\n      }\n\n      if (typeof rules[verb] === 'function') {\n        return Boolean(rules[verb].apply(rules, [user, subject, subjectName].concat(args)));\n      }\n\n      if (this.strict && typeof rules[verb] === 'undefined') {\n        throw new Error('Unknown verb \"' + verb + '\"');\n      }\n\n      return Boolean(rules[verb]);\n    }\n\n    /**\n     * Like can but subject is an array where only some has to be\n     * true for the rule to match.\n     *\n     * Note the subjects do not need to be of the same kind.\n     *\n     * @access public\n     * @param {Object} user\n     * @param {Array<Function|Object|string>} subjects\n     * @param {...*} args Any other param is passed into rule\n     * @return Boolean\n     */\n\n  }, {\n    key: 'some',\n    value: function some(user, verb, subjects) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        args[_key2 - 3] = arguments[_key2];\n      }\n\n      var _this2 = this;\n\n      return subjects.some(function (s) {\n        return _this2.can.apply(_this2, [user, verb, s].concat(args));\n      });\n    }\n\n    /**\n     * Like can but subject is an array where all has to be\n     * true for the rule to match.\n     *\n     * Note the subjects do not need to be of the same kind.\n     *\n     * @access public\n     * @param {Object} user\n     * @param {Array<Function|Object|string>} subjects\n     * @param {...*} args Any other param is passed into rule\n     * @return Boolean\n     */\n\n  }, {\n    key: 'every',\n    value: function every(user, verb, subjects) {\n      for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n        args[_key3 - 3] = arguments[_key3];\n      }\n\n      var _this3 = this;\n\n      return subjects.every(function (s) {\n        return _this3.can.apply(_this3, [user, verb, s].concat(args));\n      });\n    }\n\n    /**\n     * Mix in augments your user class with a `can` function object. This\n     * is optional and you can always call `can` directly on your\n     * Acl instance.\n     *\n     * ```\n     * user.can()\n     * user.can.some()\n     * user.can.every()\n     * ```\n     *\n     * @access public\n     * @param {Function} User A user class or contructor function\n     */\n\n  }, {\n    key: 'mixin',\n    value: function mixin(User) {\n      var acl = this;\n      User.prototype.can = function () {\n        return acl.can.apply(acl, [this].concat(Array.prototype.slice.call(arguments)));\n      };\n      User.prototype.can.every = function () {\n        return acl.every.apply(acl, [this].concat(Array.prototype.slice.call(arguments)));\n      };\n      User.prototype.can.some = function () {\n        return acl.some.apply(acl, [this].concat(Array.prototype.slice.call(arguments)));\n      };\n      return this;\n    }\n\n    /**\n     * Rules are grouped by subjects and this default mapper tries to\n     * map any non falsy input to a subject name.\n     *\n     * This is important when you want to try a verb against a rule\n     * passing in an instance of a class.\n     *\n     * - strings becomes subjects\n     * - function's names are used for subject\n     * - objects's constructor name is used for subject\n     *\n     * Override this function if your models do not match this approach.\n     *\n     * E.g. say that you are using plain data objects with a type property\n     * to indicate the \"class\" of the object.\n     *\n     * ```javascript\n     *   acl.subjectMapper = s => typeof s === 'string' ? s : s.type\n     * ```\n     *\n     * `can` will now use this function when you pass in your objects.\n     *\n     * See {@link #register register()} for how to manually map\n     * classes to subject name.\n     *\n     * @access public\n     * @param {Function|Object|string} subject\n     * @returns {string} A subject\n     */\n\n  }, {\n    key: 'subjectMapper',\n    value: function subjectMapper(subject) {\n      if (typeof subject === 'string') {\n        return subject;\n      }\n      var isFun = typeof subject === 'function';\n      if (isFun && this.registry.has(subject)) {\n        return this.registry.get(subject);\n      }\n      if (!isFun && this.registry.has(subject.constructor)) {\n        return this.registry.get(subject.constructor);\n      }\n      return isFun ? subject.name : subject.constructor.name;\n    }\n\n    /**\n     * Removes all rules, policies, and registrations\n     *\n     * @returns {Acl}\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.rules = new Map();\n      this.policies = new Map();\n      this.registry = new WeakMap();\n      return this;\n    }\n\n    /**\n     * Remove rules for subject\n     *\n     * Optionally limit to a single verb.\n     *\n     * @param {Object|Function|String} subject\n     * @param {?String} [verb=null] an optional verb\n     * @returns {Acl}\n     */\n\n  }, {\n    key: 'removeRules',\n    value: function removeRules(subject) {\n      var verb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var subjectName = this.subjectMapper(subject);\n      if (this.rules.has(subjectName)) {\n        if (verb) {\n          var rules = this.rules.get(subjectName);\n          delete rules[verb];\n          return this;\n        }\n        this.rules.delete(subjectName);\n      }\n      return this;\n    }\n\n    /**\n     * Remove policy for subject\n     *\n     * @param {Object|Function|String} subject\n     * @returns {Acl}\n     */\n\n  }, {\n    key: 'removePolicy',\n    value: function removePolicy(subject) {\n      var subjectName = this.subjectMapper(subject);\n      this.policies.delete(subjectName);\n      return this;\n    }\n\n    /**\n     * Convenience method for removing all rules and policies for a subject\n     *\n     * @param {Object|Function|String} subject\n     * @returns {Acl}\n     */\n\n  }, {\n    key: 'removeAll',\n    value: function removeAll(subject) {\n      this.removeRules(subject);\n      this.removePolicy(subject);\n      return this;\n    }\n  }]);\n\n  return Acl;\n}();\n\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// browser-acl.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d980bbec356b5650364b","\nexport const GlobalRule = 'GLOBAL_RULE'\n\nconst assumeGlobal = sub =>\n  typeof sub === 'boolean' ||\n  typeof sub === 'undefined' ||\n  (typeof sub === 'function' && sub.name === '')\n\n/**\n * Simple ACL library for the browser inspired by Laravel's guards and policies.\n */\nexport default class Acl {\n\n  /**\n   * browser-acl\n   *\n   * @access public\n   * @param {Object} options\n   * @param {Boolean} {strict=false}={} Errors out on unknown verbs when true\n   * @returns {Acl}\n   */\n  constructor({strict = false} = {}) {\n    this.strict = strict\n    this.rules = new Map()\n    this.policies = new Map()\n    this.registry = new WeakMap()\n  }\n\n  /**\n   * You add rules by providing a verb, a subject and an optional\n   * test (that otherwise defaults to true).\n   *\n   * If the test is a function it will be evaluated with the params:\n   * user, subject, and subjectName. The test value is ultimately evaluated\n   * for truthiness.\n   *\n   * Examples:\n   *\n   * ```javascript\n   * acl.rule('create', Post)\n   * acl.rule('edit', Post, (user, post) => post.userId === user.id)\n   * acl.rule('edit', Post, (user, post, verb, additionalParameter, secondAdditionalParameter) => true)\n   * acl.rule('delete', Post, false) // deleting disabled\n   * acl.rule('purgeInactive', user => user.isAdmin) // global rule\n   * ```\n   *\n   * @access public\n   * @param {Array<string>|string} verbs\n   * @param {Function|Object|string} subject?\n   * @param {Boolean|Function} test=true\n   * @returns {Acl}\n   */\n  rule(verbs, subject, test = true) {\n    if (assumeGlobal(subject)) {\n      test = typeof subject === 'undefined' ? true : subject\n      subject = GlobalRule\n    }\n    const subjectName = this.subjectMapper(subject)\n    const verbs_ = Array.isArray(verbs) ? verbs : [verbs]\n    verbs_.forEach(verb => {\n      const rules = this.rules.get(subjectName) || {}\n      rules[verb] = test\n      this.rules.set(subjectName, rules)\n    })\n    return this\n  }\n\n  /**\n   * You can group related rules into policies for a subject. The policies\n   * properties are verbs and they can plain values or functions.\n   *\n   * If the policy is a function it will be new'ed up before use.\n   *\n   * ```javascript\n   *   class Post {\n   *     constructor() {\n   *       this.view = true       // no need for a functon\n   *       this.delete = false    // not really necessary since an abscent\n   *                              // verb has the same result\n   *     }\n   *     beforeAll(verb, user, ...theRest) {\n   *       if (user.isAdmin) {\n   *         return true\n   *       }\n   *       // return nothing (undefined) to pass it on to the other rules\n   *     }\n   *     edit(user, post, verb, additionalParameter, secondAdditionalParameter) {\n   *       return post.id === user.id\n   *     }\n   *   }\n   * ```\n   *\n   * Policies are useful for grouping rules and adding more complex logic.\n   *\n   * @access public\n   * @param {Object} policy A policy with properties that are verbs\n   * @param {Function|Object|string} subject\n   * @returns {Acl}\n   */\n  policy(policy, subject) {\n    const policy_ = typeof policy === 'function' ? new policy() : policy\n    const subjectName = this.subjectMapper(subject)\n    this.policies.set(subjectName, policy_)\n    return this\n  }\n\n  /**\n   * Explicitly map a class or constructor function to a name.\n   *\n   * You would want to do this in case your code is heavily\n   * minified in which case the default mapper cannot use the\n   * simple \"reflection\" to resolve the subject name.\n   *\n   * Note: If you override the subjectMapper this is not used,\n   * bud it can be used manually through `this.registry`.\n   *\n   * @access public\n   * @param {Function} klass A class or constructor function\n   * @param {string} subjectName\n   */\n  register(klass, subjectName) {\n    this.registry.set(klass, subjectName)\n    return this\n  }\n\n  /**\n   * Performs a test if a user can perform action on subject.\n   *\n   * The action is a verb and the subject can be anything the\n   * subjectMapper can map to a subject name.\n   *\n   * E.g. if you can to test if a user can delete a post you would\n   * pass the actual post. Where as if you are testing us a user\n   * can create a post you would pass the class function or a\n   * string.\n   *\n   * ```javascript\n   *   acl->can(user, 'create', Post)\n   *   acl->can(user, 'edit', post)\n   *   acl->can(user, 'edit', post, additionalParameter, secondAdditionalParameter)\n   * ```\n   *\n   * Note that these are also available on the user if you've used\n   * the mixin:\n   *\n   * ```javascript\n   *   user->can('create', Post)\n   *   user->can('edit', post)\n   * ```\n   *\n   * @access public\n   * @param {Object} user\n   * @param {string} verb\n   * @param {Function|Object|string} subject\n   * @param {...*} args Any other param is passed into rule\n   * @return Boolean\n   */\n  can(user, verb, subject, ...args) {\n    subject = typeof subject === 'undefined' ? GlobalRule : subject\n    const subjectName = this.subjectMapper(subject)\n\n    const policy = this.policies.get(subjectName)\n    const rules = policy || this.rules.get(subjectName)\n\n    if (typeof rules === 'undefined') {\n      if (this.strict) {\n        throw new Error(`Unknown subject \"${subjectName}\"`)\n      }\n      return false\n    }\n\n    if (policy && typeof policy.beforeAll === 'function') {\n      const result = policy.beforeAll(verb, user, subject, subjectName, ...args)\n      if (typeof result !== 'undefined') {\n        return result\n      }\n    }\n\n    if (typeof rules[verb] === 'function') {\n      return Boolean(rules[verb](user, subject, subjectName, ...args))\n    }\n\n    if (this.strict && typeof rules[verb] === 'undefined') {\n      throw new Error(`Unknown verb \"${verb}\"`)\n    }\n\n    return Boolean(rules[verb])\n  }\n\n  /**\n   * Like can but subject is an array where only some has to be\n   * true for the rule to match.\n   *\n   * Note the subjects do not need to be of the same kind.\n   *\n   * @access public\n   * @param {Object} user\n   * @param {Array<Function|Object|string>} subjects\n   * @param {...*} args Any other param is passed into rule\n   * @return Boolean\n   */\n  some(user, verb, subjects, ...args) {\n    return subjects.some(s => this.can(user, verb, s, ...args))\n  }\n\n  /**\n   * Like can but subject is an array where all has to be\n   * true for the rule to match.\n   *\n   * Note the subjects do not need to be of the same kind.\n   *\n   * @access public\n   * @param {Object} user\n   * @param {Array<Function|Object|string>} subjects\n   * @param {...*} args Any other param is passed into rule\n   * @return Boolean\n   */\n  every(user, verb, subjects, ...args) {\n    return subjects.every(s => this.can(user, verb, s, ...args))\n  }\n\n  /**\n   * Mix in augments your user class with a `can` function object. This\n   * is optional and you can always call `can` directly on your\n   * Acl instance.\n   *\n   * ```\n   * user.can()\n   * user.can.some()\n   * user.can.every()\n   * ```\n   *\n   * @access public\n   * @param {Function} User A user class or contructor function\n   */\n  mixin(User) {\n    const acl = this\n    User.prototype.can = function () {\n      return acl.can(this, ...arguments)\n    }\n    User.prototype.can.every = function () {\n      return acl.every(this, ...arguments)\n    }\n    User.prototype.can.some = function () {\n      return acl.some(this, ...arguments)\n    }\n    return this\n  }\n\n  /**\n   * Rules are grouped by subjects and this default mapper tries to\n   * map any non falsy input to a subject name.\n   *\n   * This is important when you want to try a verb against a rule\n   * passing in an instance of a class.\n   *\n   * - strings becomes subjects\n   * - function's names are used for subject\n   * - objects's constructor name is used for subject\n   *\n   * Override this function if your models do not match this approach.\n   *\n   * E.g. say that you are using plain data objects with a type property\n   * to indicate the \"class\" of the object.\n   *\n   * ```javascript\n   *   acl.subjectMapper = s => typeof s === 'string' ? s : s.type\n   * ```\n   *\n   * `can` will now use this function when you pass in your objects.\n   *\n   * See {@link #register register()} for how to manually map\n   * classes to subject name.\n   *\n   * @access public\n   * @param {Function|Object|string} subject\n   * @returns {string} A subject\n   */\n  subjectMapper(subject) {\n    if (typeof subject === 'string') { return subject }\n    const isFun = typeof subject === 'function'\n    if (isFun && this.registry.has(subject)) { return this.registry.get(subject) }\n    if (!isFun && this.registry.has(subject.constructor)) { return this.registry.get(subject.constructor) }\n    return isFun ? subject.name : subject.constructor.name\n  }\n\n  /**\n   * Removes all rules, policies, and registrations\n   *\n   * @returns {Acl}\n   */\n  reset() {\n    this.rules = new Map()\n    this.policies = new Map()\n    this.registry = new WeakMap()\n    return this\n  }\n\n  /**\n   * Remove rules for subject\n   *\n   * Optionally limit to a single verb.\n   *\n   * @param {Object|Function|String} subject\n   * @param {?String} [verb=null] an optional verb\n   * @returns {Acl}\n   */\n  removeRules(subject, verb = null) {\n    const subjectName = this.subjectMapper(subject)\n    if (this.rules.has(subjectName)) {\n      if (verb) {\n        const rules = this.rules.get(subjectName)\n        delete rules[verb]\n        return this\n      }\n      this.rules.delete(subjectName)\n    }\n    return this\n  }\n\n  /**\n   * Remove policy for subject\n   *\n   * @param {Object|Function|String} subject\n   * @returns {Acl}\n   */\n  removePolicy(subject) {\n    const subjectName = this.subjectMapper(subject)\n    this.policies.delete(subjectName)\n    return this\n  }\n\n  /**\n   * Convenience method for removing all rules and policies for a subject\n   *\n   * @param {Object|Function|String} subject\n   * @returns {Acl}\n   */\n  removeAll(subject) {\n    this.removeRules(subject)\n    this.removePolicy(subject)\n    return this\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}